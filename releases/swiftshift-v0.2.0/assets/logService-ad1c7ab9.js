const g=(e,t)=>t.some(n=>e instanceof n);let E,M;function O(){return E||(E=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function x(){return M||(M=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const D=new WeakMap,m=new WeakMap,h=new WeakMap;function T(e){const t=new Promise((n,r)=>{const o=()=>{e.removeEventListener("success",a),e.removeEventListener("error",s)},a=()=>{n(u(e.result)),o()},s=()=>{r(e.error),o()};e.addEventListener("success",a),e.addEventListener("error",s)});return h.set(t,e),t}function j(e){if(D.has(e))return;const t=new Promise((n,r)=>{const o=()=>{e.removeEventListener("complete",a),e.removeEventListener("error",s),e.removeEventListener("abort",s)},a=()=>{n(),o()},s=()=>{r(e.error||new DOMException("AbortError","AbortError")),o()};e.addEventListener("complete",a),e.addEventListener("error",s),e.addEventListener("abort",s)});D.set(e,t)}let I={get(e,t,n){if(e instanceof IDBTransaction){if(t==="done")return D.get(e);if(t==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return u(e[t])},set(e,t,n){return e[t]=n,!0},has(e,t){return e instanceof IDBTransaction&&(t==="done"||t==="store")?!0:t in e}};function C(e){I=e(I)}function R(e){return x().includes(e)?function(...t){return e.apply(b(this),t),u(this.request)}:function(...t){return u(e.apply(b(this),t))}}function V(e){return typeof e=="function"?R(e):(e instanceof IDBTransaction&&j(e),g(e,O())?new Proxy(e,I):e)}function u(e){if(e instanceof IDBRequest)return T(e);if(m.has(e))return m.get(e);const t=V(e);return t!==e&&(m.set(e,t),h.set(t,e)),t}const b=e=>h.get(e);function v(e,t,{blocked:n,upgrade:r,blocking:o,terminated:a}={}){const s=indexedDB.open(e,t),l=u(s);return r&&s.addEventListener("upgradeneeded",c=>{r(u(s.result),c.oldVersion,c.newVersion,u(s.transaction),c)}),n&&s.addEventListener("blocked",c=>n(c.oldVersion,c.newVersion,c)),l.then(c=>{a&&c.addEventListener("close",()=>a()),o&&c.addEventListener("versionchange",i=>o(i.oldVersion,i.newVersion,i))}).catch(()=>{}),l}const N=["get","getKey","getAll","getAllKeys","count"],W=["put","add","delete","clear"],y=new Map;function L(e,t){if(!(e instanceof IDBDatabase&&!(t in e)&&typeof t=="string"))return;if(y.get(t))return y.get(t);const n=t.replace(/FromIndex$/,""),r=t!==n,o=W.includes(n);if(!(n in(r?IDBIndex:IDBObjectStore).prototype)||!(o||N.includes(n)))return;const a=async function(s,...l){const c=this.transaction(s,o?"readwrite":"readonly");let i=c.store;return r&&(i=i.index(l.shift())),(await Promise.all([i[n](...l),o&&c.done]))[0]};return y.set(t,a),a}C(e=>({...e,get:(t,n,r)=>L(t,n)||e.get(t,n,r),has:(t,n)=>!!L(t,n)||e.has(t,n)}));const _=["continue","continuePrimaryKey","advance"],S={},B=new WeakMap,p=new WeakMap,k={get(e,t){if(!_.includes(t))return e[t];let n=S[t];return n||(n=S[t]=function(...r){B.set(this,p.get(this)[t](...r))}),n}};async function*F(...e){let t=this;if(t instanceof IDBCursor||(t=await t.openCursor(...e)),!t)return;t=t;const n=new Proxy(t,k);for(p.set(n,t),h.set(n,b(t));t;)yield n,t=await(B.get(n)||t.continue()),B.delete(n)}function P(e,t){return t===Symbol.asyncIterator&&g(e,[IDBIndex,IDBObjectStore,IDBCursor])||t==="iterate"&&g(e,[IDBIndex,IDBObjectStore])}C(e=>({...e,get(t,n,r){return P(t,n)?F:e.get(t,n,r)},has(t,n){return P(t,n)||e.has(t,n)}}));const K="SwiftShiftRecents",X=1,d="recents",A=15;let f=null;async function w(){return f||(f=await v(K,X,{upgrade(e){e.objectStoreNames.contains(d)||e.createObjectStore(d,{keyPath:"id"})}}),f)}const $={async getAll(){return(await(await w()).getAll(d)).sort((n,r)=>r.timestamp-n.timestamp)},async add(e){const t=await w(),n={...e,id:`${Date.now()}-${Math.random().toString(36).substr(2,9)}`,timestamp:Date.now()};await t.put(d,n);const r=await this.getAll();if(r.length>A){const o=r.slice(A);for(const a of o)await t.delete(d,a.id)}return n},async delete(e){await(await w()).delete(d,e)},async clear(){await(await w()).clear(d)}},G={MAX_LOGS:50,async add(e){const{logs:t}=await chrome.storage.local.get("logs"),n=t||[],o=[{id:crypto.randomUUID(),timestamp:Date.now(),...e},...n].slice(0,this.MAX_LOGS);await chrome.storage.local.set({logs:o})},async getAll(){const{logs:e}=await chrome.storage.local.get("logs");return e||[]},async clear(){await chrome.storage.local.set({logs:[]})}};export{G as L,$ as R};
