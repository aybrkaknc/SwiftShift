const c={async init(){(await chrome.storage.local.get(["profiles","activeProfileId","recentTargets"])).profiles||await chrome.storage.local.set({profiles:{},activeProfileId:"",recentTargets:[]})},async saveProfile(t){const{profiles:e}=await chrome.storage.local.get("profiles"),r={...e,[t.id]:t},{activeProfileId:a}=await chrome.storage.local.get("activeProfileId"),s=a||t.id;await chrome.storage.local.set({profiles:r,activeProfileId:s})},async getActiveProfile(){const{activeProfileId:t,profiles:e}=await chrome.storage.local.get(["activeProfileId","profiles"]);return!t||!e?null:e[t]||null},async getAllProfiles(){const{profiles:t}=await chrome.storage.local.get("profiles");return t?Object.values(t):[]},async setActiveProfile(t){const{profiles:e}=await chrome.storage.local.get("profiles");e&&e[t]&&await chrome.storage.local.set({activeProfileId:t})},async updateProfileTargets(t,e){const{profiles:r}=await chrome.storage.local.get("profiles");r&&r[t]&&(r[t].targets=e,r[t].lastSynced=Date.now(),await chrome.storage.local.set({profiles:r}))},async addRecentTarget(t){const{recentTargets:e}=await chrome.storage.local.get("recentTargets");let r=[t,...e||[]];r=[...new Set(r)],r.length>10&&(r=r.slice(0,10)),await chrome.storage.local.set({recentTargets:r})},async clear(){await chrome.storage.local.clear()}},o={baseUrl:"https://api.telegram.org/bot",async getMe(t){try{return await(await fetch(`${this.baseUrl}${t}/getMe`)).json()}catch{return{ok:!1}}},async sendMessage(t,e){const r={chat_id:e.chatId,text:e.text,parse_mode:"HTML",link_preview_options:JSON.stringify({is_disabled:!1})};return e.threadId&&(r.message_thread_id=e.threadId),this.makeRequest(t,"sendMessage",r)},async sendPhoto(t,e){const r=new FormData;if(r.append("chat_id",e.chatId),e.caption&&r.append("caption",e.caption),e.threadId&&r.append("message_thread_id",e.threadId.toString()),e.photo instanceof Blob)r.append("photo",e.photo,"image.jpg");else if(typeof e.photo=="string")r.append("photo",e.photo);else return{success:!1,error:"Invalid photo format"};const a=await fetch(`${this.baseUrl}${t}/sendPhoto`,{method:"POST",body:r}),s=await a.json();return!a.ok||!s.ok?a.status===413||s.description&&s.description.includes("too large")?{success:!1,error:"Entity Too Large",code:413}:{success:!1,error:s.description||"Unknown Error",code:s.error_code}:{success:!0,messageId:s.result.message_id}},async getUpdates(t){try{const r=await(await fetch(`${this.baseUrl}${t}/getUpdates?limit=20`)).json();return r.ok?r.result:[]}catch(e){return console.error("Failed to fetch updates",e),[]}},async makeRequest(t,e,r){try{const a=await fetch(`${this.baseUrl}${t}/${e}`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(r)}),s=await a.json();return!a.ok||!s.ok?{success:!1,error:s.description||"API Error",code:s.error_code}:{success:!0,messageId:s.result.message_id}}catch{return{success:!1,error:"Network Error"}}},async sendPayloadSmart(t,e){return e.photo?this.sendPhoto(t,e):this.sendMessage(t,e)}},i=Object.freeze(Object.defineProperty({__proto__:null,TelegramService:o},Symbol.toStringTag,{value:"Module"}));export{c as S,o as T,i as t};
